#!/usr/bin/env node

/**
 * RECOVERY PROGRESS VALIDATION FRAMEWORK
 * =====================================
 * 
 * Purpose: Validate recovery progress against the 12-week recovery plan
 * Generated by: Error Resilience Guardian Agent
 * Date: 2025-08-10
 * 
 * Features:
 * - Milestone progress tracking
 * - Phase completion validation
 * - Timeline adherence monitoring
 * - Quality gate enforcement
 * - Automated progress reporting
 * - Risk assessment and early warning
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

class RecoveryProgressValidator {
  constructor() {
    this.baseDir = process.cwd();
    this.artifactsDir = path.join(this.baseDir, 'artifacts');
    this.backendDir = path.join(this.baseDir, 'backend-implementation');
    this.scriptsDir = path.join(this.baseDir, 'scripts');
    
    // Recovery plan structure based on recovery-actions.yml
    this.recoveryPlan = this.loadRecoveryPlan();
    this.currentWeek = this.calculateCurrentWeek();
    this.progressHistory = this.loadProgressHistory();
    this.qualityGates = this.defineQualityGates();
  }

  loadRecoveryPlan() {
    const recoveryActionsPath = path.join(this.artifactsDir, 'recovery-actions.yml');
    
    if (!fs.existsSync(recoveryActionsPath)) {
      console.error('❌ Recovery actions plan not found!');
      return null;
    }
    
    try {
      const content = fs.readFileSync(recoveryActionsPath, 'utf8');
      return yaml.load(content);
    } catch (error) {
      console.error('❌ Failed to load recovery plan:', error.message);
      return null;
    }
  }

  calculateCurrentWeek() {
    // Assuming recovery started on 2025-08-10 (today)
    const startDate = new Date('2025-08-10');
    const currentDate = new Date();
    const timeDiff = currentDate - startDate;
    const daysDiff = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
    const weeksDiff = Math.floor(daysDiff / 7) + 1; // +1 to start at week 1
    
    return Math.max(1, Math.min(12, weeksDiff)); // Clamp between 1-12 weeks
  }

  loadProgressHistory() {
    const historyPath = path.join(this.artifactsDir, 'recovery-progress-history.json');
    
    if (!fs.existsSync(historyPath)) {
      return {
        entries: [],
        lastUpdate: null,
        milestones: []
      };
    }
    
    try {
      const content = fs.readFileSync(historyPath, 'utf8');
      return JSON.parse(content);
    } catch (error) {
      console.warn('⚠️  Failed to load progress history:', error.message);
      return { entries: [], lastUpdate: null, milestones: [] };
    }
  }

  defineQualityGates() {
    return {
      week_1_checkpoint: {
        week: 1,
        criteria: {
          database_models_progress: { min: 50, weight: 0.3 },
          authentication_system_design: { min: 100, weight: 0.2 },
          api_endpoint_plan: { min: 100, weight: 0.2 },
          security_framework_design: { min: 100, weight: 0.3 }
        },
        required_deliverables: [
          'sequelize_models_50_percent',
          'authentication_design_complete',
          'api_contracts_updated',
          'security_requirements_finalized'
        ]
      },
      
      week_2_checkpoint: {
        week: 2,
        criteria: {
          database_models_complete: { min: 100, weight: 0.4 },
          authentication_implementation: { min: 70, weight: 0.3 },
          core_api_endpoints: { min: 50, weight: 0.3 }
        },
        required_deliverables: [
          'all_sequelize_models_complete',
          'jwt_authentication_working',
          'basic_crud_endpoints_functional',
          'database_migrations_working'
        ]
      },
      
      week_3_checkpoint: {
        week: 3,
        criteria: {
          authentication_complete: { min: 100, weight: 0.3 },
          core_api_endpoints_complete: { min: 100, weight: 0.4 },
          external_integrations_started: { min: 30, weight: 0.3 }
        },
        required_deliverables: [
          'full_authentication_system',
          'customer_management_endpoints',
          'route_management_endpoints',
          'stripe_integration_basic'
        ]
      },
      
      week_4_checkpoint: {
        week: 4,
        criteria: {
          phase_1_completion: { min: 90, weight: 0.5 },
          security_implementation: { min: 80, weight: 0.3 },
          integration_testing_started: { min: 50, weight: 0.2 }
        },
        required_deliverables: [
          'phase_1_foundation_complete',
          'security_audit_passed',
          'integration_tests_framework',
          'deployment_readiness_assessment'
        ]
      }
    };
  }

  async validateRecoveryProgress() {
    console.log('🔍 VALIDATING RECOVERY PROGRESS');
    console.log('===============================');
    console.log(`Current Week: ${this.currentWeek} of 12`);
    console.log(`Validation Time: ${new Date().toISOString()}\n`);

    if (!this.recoveryPlan) {
      return this.generateErrorReport('RECOVERY_PLAN_MISSING', 'Cannot validate progress without recovery plan');
    }

    const progressAssessment = {
      currentWeek: this.currentWeek,
      overallProgress: 0,
      phaseProgress: {},
      milestoneStatus: {},
      qualityGateResults: {},
      riskAssessment: {},
      recommendations: [],
      blockers: [],
      timeline: {
        onTrack: false,
        daysAhead: 0,
        daysBehind: 0,
        projectedCompletion: null
      }
    };

    // Assess each phase
    progressAssessment.phaseProgress = await this.assessPhaseProgress();
    
    // Validate milestones
    progressAssessment.milestoneStatus = await this.validateMilestones();
    
    // Check quality gates
    progressAssessment.qualityGateResults = await this.checkQualityGates();
    
    // Calculate overall progress
    progressAssessment.overallProgress = this.calculateOverallProgress(progressAssessment);
    
    // Perform risk assessment
    progressAssessment.riskAssessment = await this.performRiskAssessment(progressAssessment);
    
    // Generate recommendations
    progressAssessment.recommendations = this.generateRecommendations(progressAssessment);
    
    // Update timeline projection
    progressAssessment.timeline = this.updateTimelineProjection(progressAssessment);
    
    // Save progress record
    this.saveProgressRecord(progressAssessment);
    
    // Generate report
    this.generateProgressReport(progressAssessment);
    
    return progressAssessment;
  }

  async assessPhaseProgress() {
    const phases = {
      immediate_actions: await this.assessImmediateActions(),
      phase_1_foundation: await this.assessPhase1Foundation(),
      phase_2_business: await this.assessPhase2Business(),
      phase_3_advanced: await this.assessPhase3Advanced(),
      phase_4_production: await this.assessPhase4Production()
    };

    console.log('📊 PHASE PROGRESS ASSESSMENT');
    console.log('============================');
    
    Object.entries(phases).forEach(([phaseName, assessment]) => {
      const statusIcon = assessment.status === 'COMPLETE' ? '✅' : 
                        assessment.status === 'IN_PROGRESS' ? '🔄' : 
                        assessment.status === 'NOT_STARTED' ? '⏳' : '❌';
      
      console.log(`${statusIcon} ${phaseName.toUpperCase()}: ${assessment.completionPercentage.toFixed(1)}%`);
      
      if (assessment.blockers.length > 0) {
        console.log(`   🚫 Blockers: ${assessment.blockers.join(', ')}`);
      }
      
      if (assessment.criticalIssues.length > 0) {
        console.log(`   🚨 Critical Issues: ${assessment.criticalIssues.length}`);
      }
    });
    
    return phases;
  }

  async assessImmediateActions() {
    const actions = this.recoveryPlan?.immediate_actions?.actions || [];
    const assessment = {
      status: 'IN_PROGRESS',
      completionPercentage: 0,
      completedActions: 0,
      totalActions: actions.length,
      blockers: [],
      criticalIssues: []
    };

    if (actions.length === 0) {
      assessment.criticalIssues.push('No immediate actions defined');
      return assessment;
    }

    for (const action of actions) {
      const actionProgress = await this.assessActionProgress(action);
      
      if (actionProgress.completed) {
        assessment.completedActions++;
      } else if (actionProgress.blocked) {
        assessment.blockers.push(action.action_id);
      }
      
      if (actionProgress.criticalIssue) {
        assessment.criticalIssues.push(actionProgress.criticalIssue);
      }
    }

    assessment.completionPercentage = (assessment.completedActions / assessment.totalActions) * 100;
    assessment.status = assessment.completionPercentage === 100 ? 'COMPLETE' : 
                       assessment.completionPercentage > 0 ? 'IN_PROGRESS' : 'NOT_STARTED';

    return assessment;
  }

  async assessActionProgress(action) {
    const actionId = action.action_id;
    const progress = { completed: false, blocked: false, criticalIssue: null };

    switch (actionId) {
      case 'IA-002': // Backend Foundation Setup
        progress.completed = await this.checkBackendFoundationComplete();
        if (!progress.completed && this.currentWeek > 1) {
          progress.criticalIssue = 'Backend foundation not complete by week 1 - blocking all subsequent work';
        }
        break;
        
      case 'IA-003': // Authentication System Implementation
        progress.completed = await this.checkAuthenticationSystemComplete();
        progress.blocked = !(await this.checkBackendFoundationComplete());
        break;
        
      case 'IA-004': // API Foundation
        progress.completed = await this.checkAPIFoundationComplete();
        progress.blocked = !(await this.checkBackendFoundationComplete()) || 
                          !(await this.checkAuthenticationSystemComplete());
        break;
        
      default:
        // Generic assessment
        progress.completed = false;
    }

    return progress;
  }

  async checkBackendFoundationComplete() {
    const modelsDir = path.join(this.backendDir, 'src', 'models');
    
    if (!fs.existsSync(modelsDir)) {
      return false;
    }

    const modelFiles = fs.readdirSync(modelsDir).filter(f => f.endsWith('.ts'));
    
    // Should have at least 8 core models implemented (50% of 15 total)
    if (modelFiles.length < 8) {
      return false;
    }
    
    // Check for database connection working
    const configDir = path.join(this.backendDir, 'src', 'config');
    const dbConfigExists = fs.existsSync(path.join(configDir, 'database.ts'));
    
    return dbConfigExists && modelFiles.length >= 8;
  }

  async checkAuthenticationSystemComplete() {
    const authMiddleware = path.join(this.backendDir, 'src', 'middleware', 'auth.ts');
    
    if (!fs.existsSync(authMiddleware)) {
      return false;
    }
    
    const authContent = fs.readFileSync(authMiddleware, 'utf8');
    
    // Check for JWT implementation
    const hasJWT = authContent.includes('jwt') || authContent.includes('jsonwebtoken');
    const hasVerification = authContent.includes('verify') || authContent.includes('decode');
    
    return hasJWT && hasVerification;
  }

  async checkAPIFoundationComplete() {
    const controllersDir = path.join(this.backendDir, 'src', 'controllers');
    
    if (!fs.existsSync(controllersDir)) {
      return false;
    }
    
    const controllerFiles = fs.readdirSync(controllersDir).filter(f => f.endsWith('.ts'));
    
    // Should have at least 3 core controllers (users, customers, routes)
    const coreControllers = ['user', 'customer', 'auth'];
    const implementedControllers = controllerFiles.map(f => f.toLowerCase());
    
    const coreImplemented = coreControllers.some(core => 
      implementedControllers.some(impl => impl.includes(core))
    );
    
    return coreImplemented && controllerFiles.length >= 3;
  }

  async assessPhase1Foundation() {
    const phase1Progress = {
      status: 'NOT_STARTED',
      completionPercentage: 0,
      blockers: [],
      criticalIssues: [],
      taskProgress: {}
    };

    // Check if we should be in Phase 1 (weeks 2-4)
    if (this.currentWeek < 2) {
      return phase1Progress;
    }

    const tasks = this.recoveryPlan?.phase_1_foundation?.workstreams || {};
    let totalWeight = 0;
    let completedWeight = 0;

    for (const [workstream, details] of Object.entries(tasks)) {
      const workstreamTasks = details.tasks || [];
      const workstreamProgress = await this.assessWorkstreamProgress(workstreamTasks);
      
      phase1Progress.taskProgress[workstream] = workstreamProgress;
      
      const weight = details.estimated_hours || 50; // Default weight
      totalWeight += weight;
      completedWeight += (workstreamProgress.completionPercentage / 100) * weight;
      
      if (workstreamProgress.blockers.length > 0) {
        phase1Progress.blockers.push(...workstreamProgress.blockers);
      }
      
      if (workstreamProgress.criticalIssues.length > 0) {
        phase1Progress.criticalIssues.push(...workstreamProgress.criticalIssues);
      }
    }

    phase1Progress.completionPercentage = totalWeight > 0 ? (completedWeight / totalWeight) * 100 : 0;
    phase1Progress.status = phase1Progress.completionPercentage === 100 ? 'COMPLETE' :
                           phase1Progress.completionPercentage > 0 ? 'IN_PROGRESS' : 'NOT_STARTED';

    return phase1Progress;
  }

  async assessWorkstreamProgress(tasks) {
    const progress = {
      completionPercentage: 0,
      completedTasks: 0,
      totalTasks: tasks.length,
      blockers: [],
      criticalIssues: []
    };

    if (tasks.length === 0) {
      return progress;
    }

    for (const task of tasks) {
      const taskComplete = await this.assessTaskCompletion(task);
      
      if (taskComplete.completed) {
        progress.completedTasks++;
      } else if (taskComplete.blocked) {
        progress.blockers.push(task.task_id);
      }
      
      if (taskComplete.criticalIssue) {
        progress.criticalIssues.push(taskComplete.criticalIssue);
      }
    }

    progress.completionPercentage = (progress.completedTasks / progress.totalTasks) * 100;
    return progress;
  }

  async assessTaskCompletion(task) {
    const taskId = task.task_id;
    const completion = { completed: false, blocked: false, criticalIssue: null };

    switch (taskId) {
      case 'DB-001': // Complete Sequelize Models Implementation
        const modelsComplete = await this.checkAllModelsImplemented();
        completion.completed = modelsComplete;
        if (!modelsComplete && this.currentWeek >= 3) {
          completion.criticalIssue = 'DB-001 not complete by week 3 - blocking all API development';
        }
        break;
        
      case 'API-001': // Authentication Endpoints
        completion.completed = await this.checkAuthenticationEndpointsComplete();
        completion.blocked = !(await this.checkBackendFoundationComplete());
        break;
        
      case 'API-002': // User Management Endpoints
        completion.completed = await this.checkUserManagementEndpointsComplete();
        completion.blocked = !(await this.checkAuthenticationEndpointsComplete());
        break;
        
      case 'SEC-001': // RBAC Implementation
        completion.completed = await this.checkRBACImplementationComplete();
        completion.blocked = !(await this.checkAuthenticationEndpointsComplete());
        break;
        
      default:
        // Generic task assessment
        completion.completed = false;
        completion.blocked = false;
    }

    return completion;
  }

  async checkAllModelsImplemented() {
    const modelsDir = path.join(this.backendDir, 'src', 'models');
    
    if (!fs.existsSync(modelsDir)) {
      return false;
    }

    const modelFiles = fs.readdirSync(modelsDir).filter(f => f.endsWith('.ts'));
    
    // Should have all 15 models implemented
    return modelFiles.length >= 15;
  }

  async checkAuthenticationEndpointsComplete() {
    const routesDir = path.join(this.backendDir, 'src', 'routes');
    
    if (!fs.existsSync(routesDir)) {
      return false;
    }

    const authRoutes = path.join(routesDir, 'auth.routes.ts');
    
    if (!fs.existsSync(authRoutes)) {
      return false;
    }
    
    const authContent = fs.readFileSync(authRoutes, 'utf8');
    
    // Check for essential auth endpoints
    const hasLogin = authContent.includes('/login');
    const hasLogout = authContent.includes('/logout');
    const hasRefresh = authContent.includes('/refresh');
    
    return hasLogin && hasLogout && hasRefresh;
  }

  async checkUserManagementEndpointsComplete() {
    const controllersDir = path.join(this.backendDir, 'src', 'controllers');
    
    if (!fs.existsSync(controllersDir)) {
      return false;
    }
    
    const userController = fs.readdirSync(controllersDir)
      .find(f => f.toLowerCase().includes('user') && f.endsWith('.ts'));
    
    if (!userController) {
      return false;
    }
    
    const controllerPath = path.join(controllersDir, userController);
    const controllerContent = fs.readFileSync(controllerPath, 'utf8');
    
    // Check for CRUD operations
    const hasCreate = controllerContent.includes('create') || controllerContent.includes('POST');
    const hasRead = controllerContent.includes('get') || controllerContent.includes('GET');
    const hasUpdate = controllerContent.includes('update') || controllerContent.includes('PUT');
    const hasDelete = controllerContent.includes('delete') || controllerContent.includes('DELETE');
    
    return hasCreate && hasRead && hasUpdate && hasDelete;
  }

  async checkRBACImplementationComplete() {
    const rbacMiddleware = path.join(this.backendDir, 'src', 'middleware', 'rbac.ts');
    
    if (!fs.existsSync(rbacMiddleware)) {
      return false;
    }
    
    const rbacContent = fs.readFileSync(rbacMiddleware, 'utf8');
    
    // Check for role and permission logic
    const hasRoleCheck = rbacContent.includes('role') || rbacContent.includes('Role');
    const hasPermissionCheck = rbacContent.includes('permission') || rbacContent.includes('Permission');
    const hasMiddlewareFunction = rbacContent.includes('req') && rbacContent.includes('res') && rbacContent.includes('next');
    
    return hasRoleCheck && hasPermissionCheck && hasMiddlewareFunction;
  }

  async assessPhase2Business() {
    // Simplified assessment for phases not yet reached
    return {
      status: this.currentWeek >= 5 ? 'IN_PROGRESS' : 'NOT_STARTED',
      completionPercentage: 0,
      blockers: [],
      criticalIssues: this.currentWeek >= 5 ? ['Phase 2 not yet implemented in validator'] : []
    };
  }

  async assessPhase3Advanced() {
    return {
      status: this.currentWeek >= 8 ? 'IN_PROGRESS' : 'NOT_STARTED',
      completionPercentage: 0,
      blockers: [],
      criticalIssues: this.currentWeek >= 8 ? ['Phase 3 not yet implemented in validator'] : []
    };
  }

  async assessPhase4Production() {
    return {
      status: this.currentWeek >= 11 ? 'IN_PROGRESS' : 'NOT_STARTED',
      completionPercentage: 0,
      blockers: [],
      criticalIssues: this.currentWeek >= 11 ? ['Phase 4 not yet implemented in validator'] : []
    };
  }

  async validateMilestones() {
    const milestones = {};
    
    // Define key milestones based on recovery plan
    const keyMilestones = [
      {
        id: 'backend_foundation',
        name: 'Backend Foundation Complete',
        targetWeek: 1,
        validator: this.checkBackendFoundationComplete.bind(this)
      },
      {
        id: 'authentication_system',
        name: 'Authentication System Complete',
        targetWeek: 2,
        validator: this.checkAuthenticationSystemComplete.bind(this)
      },
      {
        id: 'api_foundation',
        name: 'API Foundation Complete',
        targetWeek: 2,
        validator: this.checkAPIFoundationComplete.bind(this)
      },
      {
        id: 'phase_1_complete',
        name: 'Phase 1 Foundation Complete',
        targetWeek: 4,
        validator: this.checkPhase1Complete.bind(this)
      }
    ];

    for (const milestone of keyMilestones) {
      const isComplete = await milestone.validator();
      const isOnTime = this.currentWeek <= milestone.targetWeek;
      const isOverdue = this.currentWeek > milestone.targetWeek && !isComplete;
      
      milestones[milestone.id] = {
        name: milestone.name,
        targetWeek: milestone.targetWeek,
        currentWeek: this.currentWeek,
        completed: isComplete,
        onTime: isOnTime,
        overdue: isOverdue,
        status: isComplete ? 'COMPLETE' : 
               isOverdue ? 'OVERDUE' : 
               isOnTime ? 'ON_TRACK' : 'AT_RISK'
      };
    }

    return milestones;
  }

  async checkPhase1Complete() {
    const backendComplete = await this.checkBackendFoundationComplete();
    const authComplete = await this.checkAuthenticationSystemComplete();
    const apiComplete = await this.checkAPIFoundationComplete();
    const modelsComplete = await this.checkAllModelsImplemented();
    
    return backendComplete && authComplete && apiComplete && modelsComplete;
  }

  async checkQualityGates() {
    const results = {};
    
    for (const [gateName, gate] of Object.entries(this.qualityGates)) {
      if (this.currentWeek >= gate.week) {
        const gateResult = await this.evaluateQualityGate(gate);
        results[gateName] = gateResult;
      }
    }

    return results;
  }

  async evaluateQualityGate(gate) {
    const result = {
      week: gate.week,
      currentWeek: this.currentWeek,
      overallScore: 0,
      criteriaResults: {},
      deliverableResults: {},
      passed: false,
      issues: []
    };

    let totalWeight = 0;
    let achievedScore = 0;

    // Evaluate criteria
    for (const [criterion, requirements] of Object.entries(gate.criteria)) {
      const score = await this.evaluateCriterion(criterion, requirements);
      result.criteriaResults[criterion] = {
        required: requirements.min,
        achieved: score,
        weight: requirements.weight,
        passed: score >= requirements.min
      };

      totalWeight += requirements.weight;
      achievedScore += (score / 100) * requirements.weight;

      if (score < requirements.min) {
        result.issues.push(`${criterion}: ${score}% (required: ${requirements.min}%)`);
      }
    }

    result.overallScore = totalWeight > 0 ? (achievedScore / totalWeight) * 100 : 0;

    // Evaluate deliverables
    for (const deliverable of gate.required_deliverables) {
      const delivered = await this.checkDeliverable(deliverable);
      result.deliverableResults[deliverable] = delivered;
      
      if (!delivered) {
        result.issues.push(`Missing deliverable: ${deliverable}`);
      }
    }

    result.passed = result.overallScore >= 80 && 
                   Object.values(result.deliverableResults).every(d => d);

    return result;
  }

  async evaluateCriterion(criterion, requirements) {
    // Map criteria to actual progress checks
    switch (criterion) {
      case 'database_models_progress':
        return await this.calculateDatabaseModelsProgress();
      
      case 'authentication_system_design':
        return await this.checkAuthenticationDesignComplete() ? 100 : 0;
      
      case 'api_endpoint_plan':
        return await this.checkAPIEndpointPlanComplete() ? 100 : 0;
      
      case 'security_framework_design':
        return await this.checkSecurityFrameworkDesignComplete() ? 100 : 0;
      
      case 'database_models_complete':
        return await this.calculateDatabaseModelsProgress();
      
      case 'authentication_implementation':
        return await this.calculateAuthenticationImplementationProgress();
      
      case 'core_api_endpoints':
        return await this.calculateCoreAPIEndpointsProgress();
      
      default:
        return 0;
    }
  }

  async calculateDatabaseModelsProgress() {
    const modelsDir = path.join(this.backendDir, 'src', 'models');
    
    if (!fs.existsSync(modelsDir)) {
      return 0;
    }

    const modelFiles = fs.readdirSync(modelsDir).filter(f => f.endsWith('.ts'));
    const requiredModels = 15; // From schema analysis
    
    return Math.min(100, (modelFiles.length / requiredModels) * 100);
  }

  async checkAuthenticationDesignComplete() {
    // Check if authentication architecture is documented
    const securityReqPath = path.join(this.artifactsDir, 'security-requirements.yml');
    
    if (!fs.existsSync(securityReqPath)) {
      return false;
    }
    
    const content = fs.readFileSync(securityReqPath, 'utf8');
    return content.includes('authentication') && content.includes('jwt');
  }

  async checkAPIEndpointPlanComplete() {
    const contractsPath = path.join(this.artifactsDir, 'api-contracts.yml');
    return fs.existsSync(contractsPath);
  }

  async checkSecurityFrameworkDesignComplete() {
    const securityReqPath = path.join(this.artifactsDir, 'security-requirements.yml');
    
    if (!fs.existsSync(securityReqPath)) {
      return false;
    }
    
    const content = fs.readFileSync(securityReqPath, 'utf8');
    return content.includes('authorization') && 
           content.includes('audit') && 
           content.includes('encryption');
  }

  async calculateAuthenticationImplementationProgress() {
    let score = 0;
    
    // Check middleware exists (25%)
    const authMiddleware = path.join(this.backendDir, 'src', 'middleware', 'auth.ts');
    if (fs.existsSync(authMiddleware)) {
      score += 25;
      
      const authContent = fs.readFileSync(authMiddleware, 'utf8');
      
      // Check JWT implementation (25%)
      if (authContent.includes('jwt') || authContent.includes('jsonwebtoken')) {
        score += 25;
      }
      
      // Check verification logic (25%)
      if (authContent.includes('verify') || authContent.includes('decode')) {
        score += 25;
      }
    }
    
    // Check auth routes exist (25%)
    const authRoutes = path.join(this.backendDir, 'src', 'routes', 'auth.routes.ts');
    if (fs.existsSync(authRoutes)) {
      score += 25;
    }
    
    return Math.min(100, score);
  }

  async calculateCoreAPIEndpointsProgress() {
    const controllersDir = path.join(this.backendDir, 'src', 'controllers');
    
    if (!fs.existsExists(controllersDir)) {
      return 0;
    }
    
    const controllerFiles = fs.readdirSync(controllersDir).filter(f => f.endsWith('.ts'));
    const requiredControllers = ['user', 'customer', 'auth', 'route']; // Core controllers
    
    let score = 0;
    const pointsPerController = 100 / requiredControllers.length;
    
    for (const required of requiredControllers) {
      const hasController = controllerFiles.some(file => 
        file.toLowerCase().includes(required.toLowerCase())
      );
      
      if (hasController) {
        score += pointsPerController;
      }
    }
    
    return Math.min(100, score);
  }

  async checkDeliverable(deliverable) {
    switch (deliverable) {
      case 'sequelize_models_50_percent':
        return (await this.calculateDatabaseModelsProgress()) >= 50;
      
      case 'authentication_design_complete':
        return await this.checkAuthenticationDesignComplete();
      
      case 'api_contracts_updated':
        return fs.existsSync(path.join(this.artifactsDir, 'api-contracts.yml'));
      
      case 'security_requirements_finalized':
        return fs.existsSync(path.join(this.artifactsDir, 'security-requirements.yml'));
      
      case 'all_sequelize_models_complete':
        return (await this.calculateDatabaseModelsProgress()) >= 100;
      
      case 'jwt_authentication_working':
        return (await this.calculateAuthenticationImplementationProgress()) >= 80;
      
      case 'basic_crud_endpoints_functional':
        return (await this.calculateCoreAPIEndpointsProgress()) >= 60;
      
      default:
        return false;
    }
  }

  calculateOverallProgress(assessment) {
    const phaseWeights = {
      immediate_actions: 0.15,
      phase_1_foundation: 0.35,
      phase_2_business: 0.25,
      phase_3_advanced: 0.15,
      phase_4_production: 0.10
    };

    let totalProgress = 0;
    
    Object.entries(assessment.phaseProgress).forEach(([phase, progress]) => {
      const weight = phaseWeights[phase] || 0;
      totalProgress += (progress.completionPercentage / 100) * weight;
    });

    return totalProgress * 100;
  }

  async performRiskAssessment(assessment) {
    const risks = [];
    const riskLevels = { LOW: 0, MEDIUM: 1, HIGH: 2, CRITICAL: 3 };
    
    // Timeline risk
    if (this.currentWeek >= 2 && assessment.overallProgress < 20) {
      risks.push({
        type: 'TIMELINE_SLIPPAGE',
        level: 'HIGH',
        description: 'Progress significantly behind schedule',
        impact: 'Project timeline will extend beyond 12 weeks',
        mitigation: 'Add additional resources, reduce scope'
      });
    }
    
    // Foundation risk
    const foundationProgress = assessment.phaseProgress.immediate_actions?.completionPercentage || 0;
    if (this.currentWeek >= 2 && foundationProgress < 80) {
      risks.push({
        type: 'FOUNDATION_INCOMPLETE',
        level: 'CRITICAL',
        description: 'Backend foundation not complete',
        impact: 'All subsequent development blocked',
        mitigation: 'Immediate focus on database models and basic API'
      });
    }
    
    // Quality risk
    const failedQualityGates = Object.values(assessment.qualityGateResults)
      .filter(gate => !gate.passed);
    
    if (failedQualityGates.length > 0) {
      risks.push({
        type: 'QUALITY_GATE_FAILURE',
        level: 'HIGH',
        description: `${failedQualityGates.length} quality gates failed`,
        impact: 'Technical debt and potential rework required',
        mitigation: 'Address quality issues before proceeding'
      });
    }
    
    // Blocker risk
    const totalBlockers = Object.values(assessment.phaseProgress)
      .reduce((sum, phase) => sum + (phase.blockers?.length || 0), 0);
    
    if (totalBlockers > 3) {
      risks.push({
        type: 'MULTIPLE_BLOCKERS',
        level: 'HIGH',
        description: `${totalBlockers} active blockers identified`,
        impact: 'Development velocity severely impacted',
        mitigation: 'Urgent blocker resolution required'
      });
    }
    
    // Calculate overall risk level
    const maxRiskLevel = risks.length > 0 ? 
      Math.max(...risks.map(r => riskLevels[r.level])) : 0;
    
    const overallRisk = Object.keys(riskLevels)[maxRiskLevel];
    
    return {
      overallRisk,
      riskCount: risks.length,
      risks,
      riskScore: risks.reduce((sum, r) => sum + riskLevels[r.level], 0)
    };
  }

  generateRecommendations(assessment) {
    const recommendations = [];
    
    // Timeline recommendations
    if (assessment.overallProgress < this.currentWeek * 8.33) { // 8.33% per week target
      recommendations.push({
        priority: 'HIGH',
        category: 'TIMELINE',
        action: 'Accelerate development velocity',
        description: 'Progress is behind schedule, need to increase team capacity or reduce scope',
        timeline: 'IMMEDIATE'
      });
    }
    
    // Phase-specific recommendations
    if (assessment.phaseProgress.immediate_actions?.completionPercentage < 90) {
      recommendations.push({
        priority: 'CRITICAL',
        category: 'FOUNDATION',
        action: 'Complete immediate actions',
        description: 'Focus all resources on completing backend foundation',
        timeline: 'THIS_WEEK'
      });
    }
    
    // Quality gate recommendations
    const failedGates = Object.entries(assessment.qualityGateResults)
      .filter(([_, gate]) => !gate.passed);
    
    if (failedGates.length > 0) {
      recommendations.push({
        priority: 'HIGH',
        category: 'QUALITY',
        action: 'Address quality gate failures',
        description: `${failedGates.length} quality gates need attention`,
        timeline: 'NEXT_WEEK'
      });
    }
    
    // Risk mitigation recommendations
    assessment.riskAssessment.risks.forEach(risk => {
      if (risk.level === 'CRITICAL' || risk.level === 'HIGH') {
        recommendations.push({
          priority: risk.level,
          category: 'RISK_MITIGATION',
          action: risk.mitigation,
          description: `Mitigate ${risk.type}: ${risk.description}`,
          timeline: risk.level === 'CRITICAL' ? 'IMMEDIATE' : 'THIS_WEEK'
        });
      }
    });
    
    return recommendations.sort((a, b) => {
      const priorityOrder = { CRITICAL: 0, HIGH: 1, MEDIUM: 2, LOW: 3 };
      return priorityOrder[a.priority] - priorityOrder[b.priority];
    });
  }

  updateTimelineProjection(assessment) {
    const currentProgressRate = assessment.overallProgress / this.currentWeek;
    const targetProgress = 100;
    
    const projectedWeeksToComplete = targetProgress / currentProgressRate;
    const projectedCompletion = new Date();
    projectedCompletion.setDate(projectedCompletion.getDate() + (projectedWeeksToComplete - this.currentWeek) * 7);
    
    const originalTarget = 12; // 12-week plan
    const daysAhead = Math.max(0, (originalTarget - projectedWeeksToComplete) * 7);
    const daysBehind = Math.max(0, (projectedWeeksToComplete - originalTarget) * 7);
    
    return {
      onTrack: projectedWeeksToComplete <= originalTarget + 1, // 1 week tolerance
      daysAhead: Math.round(daysAhead),
      daysBehind: Math.round(daysBehind),
      projectedCompletion: projectedCompletion.toISOString(),
      projectedWeeks: Math.round(projectedWeeksToComplete),
      progressRate: currentProgressRate
    };
  }

  saveProgressRecord(assessment) {
    const record = {
      timestamp: new Date().toISOString(),
      week: this.currentWeek,
      overallProgress: assessment.overallProgress,
      phaseProgress: assessment.phaseProgress,
      milestoneStatus: assessment.milestoneStatus,
      qualityGateResults: assessment.qualityGateResults,
      riskAssessment: assessment.riskAssessment,
      timeline: assessment.timeline
    };

    this.progressHistory.entries.push(record);
    this.progressHistory.lastUpdate = record.timestamp;

    // Keep only last 50 entries to prevent file from growing too large
    if (this.progressHistory.entries.length > 50) {
      this.progressHistory.entries = this.progressHistory.entries.slice(-50);
    }

    const historyPath = path.join(this.artifactsDir, 'recovery-progress-history.json');
    fs.writeFileSync(historyPath, JSON.stringify(this.progressHistory, null, 2));
  }

  generateProgressReport(assessment) {
    console.log('\n📊 RECOVERY PROGRESS VALIDATION REPORT');
    console.log('======================================');
    console.log(`Week: ${this.currentWeek} of 12`);
    console.log(`Overall Progress: ${assessment.overallProgress.toFixed(1)}%`);
    console.log(`Timeline Status: ${assessment.timeline.onTrack ? '✅ ON TRACK' : '🚨 BEHIND SCHEDULE'}`);
    
    if (assessment.timeline.daysBehind > 0) {
      console.log(`Days Behind: ${assessment.timeline.daysBehind}`);
    }
    
    if (assessment.timeline.daysAhead > 0) {
      console.log(`Days Ahead: ${assessment.timeline.daysAhead}`);
    }
    
    console.log(`\n📈 PHASE PROGRESS`);
    Object.entries(assessment.phaseProgress).forEach(([phase, progress]) => {
      const statusIcon = progress.status === 'COMPLETE' ? '✅' : 
                        progress.status === 'IN_PROGRESS' ? '🔄' : '⏳';
      console.log(`${statusIcon} ${phase}: ${progress.completionPercentage.toFixed(1)}%`);
    });
    
    console.log(`\n🎯 MILESTONE STATUS`);
    Object.entries(assessment.milestoneStatus).forEach(([id, milestone]) => {
      const statusIcon = milestone.status === 'COMPLETE' ? '✅' : 
                        milestone.status === 'OVERDUE' ? '🚨' : 
                        milestone.status === 'ON_TRACK' ? '🔄' : '⏳';
      console.log(`${statusIcon} ${milestone.name}: ${milestone.status}`);
    });
    
    console.log(`\n🚪 QUALITY GATES`);
    Object.entries(assessment.qualityGateResults).forEach(([gate, result]) => {
      const statusIcon = result.passed ? '✅' : '🚨';
      console.log(`${statusIcon} ${gate}: ${result.overallScore.toFixed(1)}% (Week ${result.week})`);
    });
    
    console.log(`\n⚠️  RISK ASSESSMENT`);
    console.log(`Overall Risk: ${assessment.riskAssessment.overallRisk}`);
    console.log(`Active Risks: ${assessment.riskAssessment.riskCount}`);
    
    if (assessment.riskAssessment.risks.length > 0) {
      console.log('\nTop Risks:');
      assessment.riskAssessment.risks.slice(0, 3).forEach(risk => {
        console.log(`🚨 ${risk.type} (${risk.level}): ${risk.description}`);
      });
    }
    
    console.log(`\n💡 RECOMMENDATIONS`);
    assessment.recommendations.slice(0, 5).forEach((rec, index) => {
      console.log(`${index + 1}. [${rec.priority}] ${rec.action}`);
      console.log(`   ${rec.description}`);
    });
    
    // Save detailed report
    const reportPath = path.join(this.artifactsDir, 'recovery-progress-report.yml');
    fs.writeFileSync(reportPath, yaml.dump({
      metadata: {
        generated_at: new Date().toISOString(),
        current_week: this.currentWeek,
        recovery_plan_version: '1.0.0'
      },
      summary: {
        overall_progress: assessment.overallProgress,
        timeline_status: assessment.timeline.onTrack ? 'ON_TRACK' : 'BEHIND_SCHEDULE',
        days_behind: assessment.timeline.daysBehind,
        risk_level: assessment.riskAssessment.overallRisk
      },
      detailed_assessment: assessment
    }));
    
    console.log(`\n📄 Detailed report saved: ${reportPath}`);
    
    return assessment;
  }

  generateErrorReport(errorType, message) {
    return {
      error: true,
      errorType,
      message,
      timestamp: new Date().toISOString(),
      currentWeek: this.currentWeek
    };
  }
}

// Error handling
process.on('uncaughtException', (error) => {
  console.error('🚨 PROGRESS VALIDATOR ERROR:', error);
  process.exit(1);
});

// CLI interface
if (require.main === module) {
  const validator = new RecoveryProgressValidator();
  
  const args = process.argv.slice(2);
  
  if (args.includes('--continuous')) {
    console.log('👁️  Starting continuous progress validation...');
    
    // Run validation every hour
    const runValidation = () => {
      validator.validateRecoveryProgress().then(result => {
        if (result.error) {
          console.error(`❌ Validation failed: ${result.message}`);
        } else {
          console.log(`✅ Progress validation completed: ${result.overallProgress.toFixed(1)}%`);
          
          // Check for critical issues
          if (result.riskAssessment.overallRisk === 'CRITICAL') {
            console.log('🚨 CRITICAL RISKS DETECTED - IMMEDIATE ATTENTION REQUIRED');
          }
        }
      }).catch(console.error);
    };
    
    // Run immediately and then every hour
    runValidation();
    setInterval(runValidation, 60 * 60 * 1000); // Every hour
    
  } else {
    // Run single validation
    validator.validateRecoveryProgress().then(result => {
      const exitCode = result.error || result.riskAssessment?.overallRisk === 'CRITICAL' ? 1 : 0;
      process.exit(exitCode);
    }).catch(error => {
      console.error('❌ Validation failed:', error);
      process.exit(1);
    });
  }
}

module.exports = RecoveryProgressValidator;