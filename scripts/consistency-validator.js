#!/usr/bin/env node

/**
 * CONSISTENCY VALIDATION ENGINE - REAL-TIME INCONSISTENCY DETECTION
 * ================================================================
 * 
 * Purpose: Detect new inconsistencies between agent implementations in real-time
 * Generated by: Error Resilience Guardian Agent
 * Date: 2025-08-10
 * 
 * Features:
 * - Cross-artifact consistency validation
 * - Implementation vs documentation drift detection
 * - Agent coordination conflict identification
 * - Automated inconsistency reporting
 * - Prevention of new critical issues during recovery
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

class ConsistencyValidator {
  constructor() {
    this.baseDir = process.cwd();
    this.artifactsDir = path.join(this.baseDir, 'artifacts');
    this.backendDir = path.join(this.baseDir, 'backend-implementation');
    
    this.validationRules = {
      databaseConsistency: this.validateDatabaseConsistency.bind(this),
      apiContractCompliance: this.validateAPIContractCompliance.bind(this),
      securityRequirementAlignment: this.validateSecurityRequirementAlignment.bind(this),
      architecturalIntegrity: this.validateArchitecturalIntegrity.bind(this),
      externalIntegrationConsistency: this.validateExternalIntegrationConsistency.bind(this),
      documentationSynchronization: this.validateDocumentationSynchronization.bind(this)
    };
    
    this.inconsistencies = [];
    this.lastValidation = null;
    this.validationHistory = [];
  }

  async runFullValidation() {
    console.log('🔍 RUNNING COMPREHENSIVE CONSISTENCY VALIDATION');
    console.log('===============================================');
    console.log(`Validation Time: ${new Date().toISOString()}\n`);

    this.inconsistencies = [];
    const validationResults = {};

    // Run all validation rules
    for (const [ruleName, ruleFunction] of Object.entries(this.validationRules)) {
      console.log(`🔍 Validating: ${ruleName}`);
      
      try {
        const result = await ruleFunction();
        validationResults[ruleName] = result;
        
        if (result.inconsistencies && result.inconsistencies.length > 0) {
          this.inconsistencies.push(...result.inconsistencies.map(inc => ({
            ...inc,
            category: ruleName,
            timestamp: new Date()
          })));
        }
        
        const statusIcon = result.status === 'CONSISTENT' ? '✅' : 
                          result.status === 'MINOR_ISSUES' ? '⚠️' : '🚨';
        console.log(`   ${statusIcon} ${result.status} - ${result.summary}`);
        
      } catch (error) {
        console.error(`   ❌ ERROR validating ${ruleName}:`, error.message);
        validationResults[ruleName] = {
          status: 'VALIDATION_ERROR',
          error: error.message,
          inconsistencies: [{
            severity: 'HIGH',
            type: 'VALIDATION_FAILURE',
            description: `Failed to validate ${ruleName}: ${error.message}`,
            impact: 'Cannot assess consistency for this category'
          }]
        };
      }
    }

    this.generateValidationReport(validationResults);
    this.updateErrorReportsIfNeeded();
    
    return {
      totalInconsistencies: this.inconsistencies.length,
      criticalIssues: this.inconsistencies.filter(i => i.severity === 'CRITICAL').length,
      highIssues: this.inconsistencies.filter(i => i.severity === 'HIGH').length,
      validationResults
    };
  }

  async validateDatabaseConsistency() {
    console.log('   📊 Checking database schema vs models alignment...');
    
    const inconsistencies = [];
    
    // Load database schema
    const schemaPath = path.join(this.artifactsDir, 'database-schema.sql');
    if (!fs.existsSync(schemaPath)) {
      return {
        status: 'CRITICAL_ISSUE',
        summary: 'Database schema file missing',
        inconsistencies: [{
          severity: 'CRITICAL',
          type: 'MISSING_SCHEMA',
          description: 'Database schema file not found at artifacts/database-schema.sql',
          impact: 'Cannot validate database consistency'
        }]
      };
    }

    const schemaContent = fs.readFileSync(schemaPath, 'utf8');
    
    // Extract table definitions from schema
    const tableMatches = schemaContent.match(/CREATE TABLE (\w+)/g) || [];
    const schemaTables = tableMatches.map(match => match.replace('CREATE TABLE ', ''));
    
    // Check implemented models
    const modelsDir = path.join(this.backendDir, 'src', 'models');
    let implementedModels = [];
    
    if (fs.existsSync(modelsDir)) {
      implementedModels = fs.readdirSync(modelsDir)
        .filter(f => f.endsWith('.ts'))
        .map(f => f.replace('.ts', ''));
    }
    
    // Find missing models
    const missingModels = schemaTables.filter(table => 
      !implementedModels.some(model => 
        model.toLowerCase().includes(table.toLowerCase()) || 
        table.toLowerCase().includes(model.toLowerCase())
      )
    );
    
    // Find extra models (not in schema)
    const extraModels = implementedModels.filter(model => 
      !schemaTables.some(table => 
        model.toLowerCase().includes(table.toLowerCase()) || 
        table.toLowerCase().includes(model.toLowerCase())
      )
    );
    
    // Check foreign key relationships
    const foreignKeyMatches = schemaContent.match(/REFERENCES (\w+)\(/g) || [];
    const schemaReferences = foreignKeyMatches.map(match => 
      match.replace('REFERENCES ', '').replace('(', '')
    );
    
    // Add inconsistencies
    if (missingModels.length > 0) {
      inconsistencies.push({
        severity: 'CRITICAL',
        type: 'MISSING_MODELS',
        description: `Database models missing for tables: ${missingModels.join(', ')}`,
        impact: 'API endpoints cannot function without these models',
        affectedTables: missingModels,
        recommendations: [
          'Implement Sequelize models for all missing tables',
          'Ensure model relationships match schema foreign keys',
          'Add proper validation and constraints'
        ]
      });
    }
    
    if (extraModels.length > 0) {
      inconsistencies.push({
        severity: 'MEDIUM',
        type: 'EXTRA_MODELS',
        description: `Models implemented without corresponding schema tables: ${extraModels.join(', ')}`,
        impact: 'These models may not have proper database backing',
        affectedModels: extraModels
      });
    }
    
    // Check for relationship consistency
    if (implementedModels.length > 0) {
      for (const model of implementedModels) {
        const modelPath = path.join(modelsDir, `${model}.ts`);
        if (fs.existsSync(modelPath)) {
          const modelContent = fs.readFileSync(modelPath, 'utf8');
          
          // Check if model has associations
          const hasAssociations = modelContent.includes('hasMany') || 
                                 modelContent.includes('belongsTo') || 
                                 modelContent.includes('belongsToMany');
          
          if (!hasAssociations && schemaReferences.length > 0) {
            inconsistencies.push({
              severity: 'HIGH',
              type: 'MISSING_ASSOCIATIONS',
              description: `Model ${model} missing associations despite schema having foreign keys`,
              impact: 'Related data queries will fail, referential integrity not enforced',
              affectedModel: model
            });
          }
        }
      }
    }
    
    const status = inconsistencies.length === 0 ? 'CONSISTENT' :
                  inconsistencies.some(i => i.severity === 'CRITICAL') ? 'CRITICAL_ISSUE' :
                  'MINOR_ISSUES';
    
    return {
      status,
      summary: `${schemaTables.length} schema tables, ${implementedModels.length} implemented models, ${inconsistencies.length} issues`,
      inconsistencies,
      metrics: {
        schemaTables: schemaTables.length,
        implementedModels: implementedModels.length,
        missingModels: missingModels.length,
        extraModels: extraModels.length,
        consistencyPercentage: ((schemaTables.length - missingModels.length) / schemaTables.length) * 100
      }
    };
  }

  async validateAPIContractCompliance() {
    console.log('   🔌 Checking API contracts vs implementation alignment...');
    
    const inconsistencies = [];
    
    // Load API contracts
    const contractsPath = path.join(this.artifactsDir, 'api-contracts.yml');
    if (!fs.existsSync(contractsPath)) {
      return {
        status: 'CRITICAL_ISSUE',
        summary: 'API contracts file missing',
        inconsistencies: [{
          severity: 'CRITICAL',
          type: 'MISSING_CONTRACTS',
          description: 'API contracts file not found',
          impact: 'Cannot validate API implementation consistency'
        }]
      };
    }
    
    const contractsContent = fs.readFileSync(contractsPath, 'utf8');
    let contracts;
    
    try {
      contracts = yaml.load(contractsContent);
    } catch (error) {
      return {
        status: 'CRITICAL_ISSUE',
        summary: 'Invalid API contracts YAML',
        inconsistencies: [{
          severity: 'CRITICAL',
          type: 'INVALID_CONTRACTS',
          description: `API contracts YAML is invalid: ${error.message}`,
          impact: 'Cannot parse API contracts for validation'
        }]
      };
    }
    
    // Extract endpoint definitions
    const definedEndpoints = this.extractEndpointsFromContracts(contracts);
    
    // Check implemented controllers and routes
    const implementedEndpoints = this.findImplementedEndpoints();
    
    // Find missing implementations
    const missingImplementations = definedEndpoints.filter(endpoint => 
      !implementedEndpoints.some(impl => 
        impl.path === endpoint.path && impl.method === endpoint.method
      )
    );
    
    // Find implementations without contracts
    const undocumentedImplementations = implementedEndpoints.filter(impl => 
      !definedEndpoints.some(endpoint => 
        endpoint.path === impl.path && endpoint.method === impl.method
      )
    );
    
    // Add inconsistencies
    if (missingImplementations.length > 0) {
      inconsistencies.push({
        severity: 'CRITICAL',
        type: 'MISSING_IMPLEMENTATIONS',
        description: `${missingImplementations.length} API endpoints documented but not implemented`,
        impact: 'Frontend applications will fail when calling these endpoints',
        affectedEndpoints: missingImplementations.slice(0, 10), // Show first 10
        totalMissing: missingImplementations.length,
        recommendations: [
          'Implement missing controllers and route handlers',
          'Ensure proper request validation',
          'Add appropriate error handling'
        ]
      });
    }
    
    if (undocumentedImplementations.length > 0) {
      inconsistencies.push({
        severity: 'MEDIUM',
        type: 'UNDOCUMENTED_IMPLEMENTATIONS',
        description: `${undocumentedImplementations.length} API endpoints implemented but not documented`,
        impact: 'Frontend developers unaware of available endpoints',
        affectedEndpoints: undocumentedImplementations,
        recommendations: [
          'Update API contracts to include all implemented endpoints',
          'Add proper OpenAPI documentation'
        ]
      });
    }
    
    // Check response schema consistency
    const schemaInconsistencies = await this.validateResponseSchemas(definedEndpoints, implementedEndpoints);
    inconsistencies.push(...schemaInconsistencies);
    
    const status = inconsistencies.length === 0 ? 'CONSISTENT' :
                  inconsistencies.some(i => i.severity === 'CRITICAL') ? 'CRITICAL_ISSUE' :
                  'MINOR_ISSUES';
    
    return {
      status,
      summary: `${definedEndpoints.length} defined endpoints, ${implementedEndpoints.length} implemented, ${inconsistencies.length} issues`,
      inconsistencies,
      metrics: {
        definedEndpoints: definedEndpoints.length,
        implementedEndpoints: implementedEndpoints.length,
        missingImplementations: missingImplementations.length,
        undocumentedImplementations: undocumentedImplementations.length,
        implementationCompleteness: ((implementedEndpoints.length / definedEndpoints.length) * 100) || 0
      }
    };
  }

  extractEndpointsFromContracts(contracts) {
    const endpoints = [];
    
    // Navigate through OpenAPI/Swagger structure
    if (contracts.paths) {
      Object.entries(contracts.paths).forEach(([path, methods]) => {
        Object.entries(methods).forEach(([method, definition]) => {
          if (['get', 'post', 'put', 'delete', 'patch'].includes(method.toLowerCase())) {
            endpoints.push({
              path: path,
              method: method.toUpperCase(),
              operationId: definition.operationId,
              summary: definition.summary,
              tags: definition.tags || []
            });
          }
        });
      });
    }
    
    return endpoints;
  }

  findImplementedEndpoints() {
    const endpoints = [];
    
    // Check routes directory
    const routesDir = path.join(this.backendDir, 'src', 'routes');
    if (!fs.existsSync(routesDir)) {
      return endpoints;
    }
    
    const routeFiles = fs.readdirSync(routesDir).filter(f => f.endsWith('.ts'));
    
    routeFiles.forEach(file => {
      const filePath = path.join(routesDir, file);
      const content = fs.readFileSync(filePath, 'utf8');
      
      // Extract route definitions (simple regex-based approach)
      const routeMatches = content.match(/(router\.|app\.)(get|post|put|delete|patch)\s*\(\s*['"`]([^'"`]+)['"`]/g) || [];
      
      routeMatches.forEach(match => {
        const methodMatch = match.match(/(get|post|put|delete|patch)/i);
        const pathMatch = match.match(/['"`]([^'"`]+)['"`]/);
        
        if (methodMatch && pathMatch) {
          endpoints.push({
            path: pathMatch[1],
            method: methodMatch[1].toUpperCase(),
            file: file,
            implementation: 'DETECTED'
          });
        }
      });
    });
    
    return endpoints;
  }

  async validateResponseSchemas(definedEndpoints, implementedEndpoints) {
    // This would validate that response schemas match implementation
    // For now, return empty array as this requires deeper analysis
    return [];
  }

  async validateSecurityRequirementAlignment() {
    console.log('   🔐 Checking security requirements vs implementation...');
    
    const inconsistencies = [];
    
    // Load security requirements
    const securityReqPath = path.join(this.artifactsDir, 'security-requirements.yml');
    if (!fs.existsSync(securityReqPath)) {
      inconsistencies.push({
        severity: 'CRITICAL',
        type: 'MISSING_SECURITY_REQUIREMENTS',
        description: 'Security requirements file missing',
        impact: 'Cannot validate security implementation'
      });
    } else {
      const securityContent = fs.readFileSync(securityReqPath, 'utf8');
      let securityReq;
      
      try {
        securityReq = yaml.load(securityContent);
      } catch (error) {
        inconsistencies.push({
          severity: 'HIGH',
          type: 'INVALID_SECURITY_REQUIREMENTS',
          description: `Security requirements YAML invalid: ${error.message}`,
          impact: 'Cannot parse security requirements'
        });
        securityReq = {};
      }
      
      // Check authentication implementation
      const authImplemented = this.checkAuthenticationImplementation();
      if (securityReq.authentication && !authImplemented.implemented) {
        inconsistencies.push({
          severity: 'CRITICAL',
          type: 'MISSING_AUTHENTICATION',
          description: 'Authentication system required but not implemented',
          impact: 'System has no access control',
          requirements: securityReq.authentication,
          recommendations: [
            'Implement JWT authentication middleware',
            'Add user login/logout endpoints',
            'Create session management'
          ]
        });
      }
      
      // Check authorization (RBAC) implementation
      const rbacImplemented = this.checkRBACImplementation();
      if (securityReq.authorization && !rbacImplemented.implemented) {
        inconsistencies.push({
          severity: 'CRITICAL',
          type: 'MISSING_AUTHORIZATION',
          description: 'Role-based access control required but not implemented',
          impact: 'Users can access all system resources',
          requirements: securityReq.authorization,
          recommendations: [
            'Implement RBAC middleware',
            'Define role-permission mappings',
            'Add access control checks'
          ]
        });
      }
      
      // Check audit logging
      const auditImplemented = this.checkAuditLoggingImplementation();
      if (securityReq.audit_logging && !auditImplemented.implemented) {
        inconsistencies.push({
          severity: 'HIGH',
          type: 'MISSING_AUDIT_LOGGING',
          description: 'Audit logging required but not implemented',
          impact: 'No compliance audit trail',
          recommendations: [
            'Implement audit logging middleware',
            'Log all sensitive operations',
            'Store audit logs securely'
          ]
        });
      }
    }
    
    const status = inconsistencies.length === 0 ? 'CONSISTENT' :
                  inconsistencies.some(i => i.severity === 'CRITICAL') ? 'CRITICAL_ISSUE' :
                  'MINOR_ISSUES';
    
    return {
      status,
      summary: `Security implementation validation completed, ${inconsistencies.length} issues found`,
      inconsistencies
    };
  }

  checkAuthenticationImplementation() {
    const authMiddlewarePath = path.join(this.backendDir, 'src', 'middleware', 'auth.ts');
    
    if (!fs.existsSync(authMiddlewarePath)) {
      return { implemented: false, reason: 'Auth middleware file missing' };
    }
    
    const authContent = fs.readFileSync(authMiddlewarePath, 'utf8');
    
    if (!authContent.includes('jwt') && !authContent.includes('jsonwebtoken')) {
      return { implemented: false, reason: 'No JWT implementation found' };
    }
    
    if (!authContent.includes('verify') && !authContent.includes('decode')) {
      return { implemented: false, reason: 'No token verification logic found' };
    }
    
    return { implemented: true };
  }

  checkRBACImplementation() {
    const rbacMiddlewarePath = path.join(this.backendDir, 'src', 'middleware', 'rbac.ts');
    
    if (!fs.existsSync(rbacMiddlewarePath)) {
      return { implemented: false, reason: 'RBAC middleware file missing' };
    }
    
    const rbacContent = fs.readFileSync(rbacMiddlewarePath, 'utf8');
    
    if (!rbacContent.includes('role') && !rbacContent.includes('permission')) {
      return { implemented: false, reason: 'No role/permission logic found' };
    }
    
    return { implemented: true };
  }

  checkAuditLoggingImplementation() {
    const middlewareDir = path.join(this.backendDir, 'src', 'middleware');
    
    if (!fs.existsSync(middlewareDir)) {
      return { implemented: false, reason: 'Middleware directory missing' };
    }
    
    const middlewareFiles = fs.readdirSync(middlewareDir);
    const auditFile = middlewareFiles.find(f => 
      f.includes('audit') || f.includes('logging')
    );
    
    if (!auditFile) {
      return { implemented: false, reason: 'No audit logging middleware found' };
    }
    
    return { implemented: true };
  }

  async validateArchitecturalIntegrity() {
    console.log('   🏗️  Checking architectural integrity...');
    
    const inconsistencies = [];
    
    // Load system design
    const systemDesignPath = path.join(this.artifactsDir, 'system-design.yml');
    if (!fs.existsSync(systemDesignPath)) {
      return {
        status: 'CRITICAL_ISSUE',
        summary: 'System design file missing',
        inconsistencies: [{
          severity: 'CRITICAL',
          type: 'MISSING_ARCHITECTURE',
          description: 'System design file not found',
          impact: 'Cannot validate architectural consistency'
        }]
      };
    }
    
    const systemDesign = yaml.load(fs.readFileSync(systemDesignPath, 'utf8'));
    
    // Check microservices vs implementation
    if (systemDesign.system?.architecture_type === 'microservices') {
      const implementationStructure = this.analyzeImplementationStructure();
      
      if (implementationStructure.type === 'monolith') {
        inconsistencies.push({
          severity: 'HIGH',
          type: 'ARCHITECTURE_MISMATCH',
          description: 'Architecture specifies microservices but implementation is monolithic',
          impact: 'Scalability and deployment strategy will not match design',
          designedAs: 'microservices',
          implementedAs: 'monolith',
          recommendations: [
            'Restructure into separate service directories',
            'Implement service-to-service communication',
            'Add service discovery mechanisms'
          ]
        });
      }
    }
    
    // Check service boundaries
    if (systemDesign.services) {
      const designedServices = Object.keys(systemDesign.services);
      const implementedServices = this.findImplementedServices();
      
      const missingServices = designedServices.filter(service => 
        !implementedServices.includes(service)
      );
      
      if (missingServices.length > 0) {
        inconsistencies.push({
          severity: 'HIGH',
          type: 'MISSING_SERVICES',
          description: `Services defined in architecture but not implemented: ${missingServices.join(', ')}`,
          impact: 'System functionality will be incomplete',
          missingServices
        });
      }
    }
    
    const status = inconsistencies.length === 0 ? 'CONSISTENT' :
                  inconsistencies.some(i => i.severity === 'CRITICAL') ? 'CRITICAL_ISSUE' :
                  'MINOR_ISSUES';
    
    return {
      status,
      summary: `Architecture validation completed, ${inconsistencies.length} issues found`,
      inconsistencies
    };
  }

  analyzeImplementationStructure() {
    // Check if implementation follows microservices pattern
    const srcDir = path.join(this.backendDir, 'src');
    
    if (!fs.existsSync(srcDir)) {
      return { type: 'unknown', reason: 'No source directory found' };
    }
    
    const srcContents = fs.readdirSync(srcDir);
    
    // Look for service-oriented structure
    const hasServiceDirs = srcContents.some(item => 
      fs.statSync(path.join(srcDir, item)).isDirectory() && 
      (item.includes('service') || item.includes('microservice'))
    );
    
    // Look for monolithic structure
    const hasMonolithicStructure = srcContents.includes('controllers') && 
                                  srcContents.includes('models') && 
                                  srcContents.includes('routes');
    
    if (hasServiceDirs) {
      return { type: 'microservices' };
    } else if (hasMonolithicStructure) {
      return { type: 'monolith' };
    } else {
      return { type: 'unknown', reason: 'Cannot determine architecture pattern' };
    }
  }

  findImplementedServices() {
    // This would analyze the codebase to find implemented services
    // For now, return basic analysis based on directory structure
    const services = [];
    
    const srcDir = path.join(this.backendDir, 'src');
    if (fs.existsSync(srcDir)) {
      const contents = fs.readdirSync(srcDir);
      
      // Look for service-related directories
      contents.forEach(item => {
        const itemPath = path.join(srcDir, item);
        if (fs.statSync(itemPath).isDirectory()) {
          if (item.includes('service') || item === 'services') {
            services.push(item);
          }
        }
      });
      
      // If no services found but has typical structure, assume core service
      if (services.length === 0 && contents.includes('controllers')) {
        services.push('core_service');
      }
    }
    
    return services;
  }

  async validateExternalIntegrationConsistency() {
    console.log('   🔌 Checking external integration consistency...');
    
    const inconsistencies = [];
    
    // Load system design for expected integrations
    const systemDesignPath = path.join(this.artifactsDir, 'system-design.yml');
    let expectedIntegrations = [];
    
    if (fs.existsSync(systemDesignPath)) {
      const systemDesign = yaml.load(fs.readFileSync(systemDesignPath, 'utf8'));
      
      if (systemDesign.external_integrations) {
        expectedIntegrations = Object.keys(systemDesign.external_integrations);
      }
    }
    
    // Check implemented integrations
    const implementedIntegrations = this.findImplementedIntegrations();
    
    // Find missing integrations
    const missingIntegrations = expectedIntegrations.filter(integration => 
      !implementedIntegrations.some(impl => 
        impl.name.toLowerCase().includes(integration.toLowerCase())
      )
    );
    
    if (missingIntegrations.length > 0) {
      inconsistencies.push({
        severity: 'HIGH',
        type: 'MISSING_INTEGRATIONS',
        description: `External integrations defined but not implemented: ${missingIntegrations.join(', ')}`,
        impact: 'Core business functionality will be missing',
        missingIntegrations,
        recommendations: [
          'Implement missing integration services',
          'Add proper error handling and fallbacks',
          'Test integration connectivity'
        ]
      });
    }
    
    const status = inconsistencies.length === 0 ? 'CONSISTENT' : 'MINOR_ISSUES';
    
    return {
      status,
      summary: `External integration validation completed, ${inconsistencies.length} issues found`,
      inconsistencies,
      metrics: {
        expectedIntegrations: expectedIntegrations.length,
        implementedIntegrations: implementedIntegrations.length,
        missingIntegrations: missingIntegrations.length
      }
    };
  }

  findImplementedIntegrations() {
    const integrations = [];
    
    // Check services directory
    const servicesDir = path.join(this.backendDir, 'src', 'services');
    if (fs.existsSync(servicesDir)) {
      const serviceFiles = fs.readdirSync(servicesDir);
      
      serviceFiles.forEach(file => {
        const filePath = path.join(servicesDir, file);
        const content = fs.readFileSync(filePath, 'utf8');
        
        // Check for common integration patterns
        const integrationPatterns = [
          { name: 'stripe', pattern: /stripe/i },
          { name: 'twilio', pattern: /twilio/i },
          { name: 'sendgrid', pattern: /sendgrid/i },
          { name: 'samsara', pattern: /samsara/i },
          { name: 'mapbox', pattern: /mapbox/i },
          { name: 'airtable', pattern: /airtable/i }
        ];
        
        integrationPatterns.forEach(({ name, pattern }) => {
          if (pattern.test(content)) {
            integrations.push({ name, file, status: 'DETECTED' });
          }
        });
      });
    }
    
    return integrations;
  }

  async validateDocumentationSynchronization() {
    console.log('   📚 Checking documentation synchronization...');
    
    const inconsistencies = [];
    
    // Check timestamp consistency between related files
    const artifactFiles = [
      'api-contracts.yml',
      'database-schema.sql',
      'security-requirements.yml',
      'system-design.yml',
      'error-reports.md'
    ].map(file => path.join(this.artifactsDir, file))
     .filter(fs.existsSync);
    
    if (artifactFiles.length === 0) {
      return {
        status: 'CRITICAL_ISSUE',
        summary: 'No artifact files found',
        inconsistencies: [{
          severity: 'CRITICAL',
          type: 'MISSING_ARTIFACTS',
          description: 'No artifact files found for synchronization check',
          impact: 'Cannot validate documentation consistency'
        }]
      };
    }
    
    // Check file timestamps
    const fileStats = artifactFiles.map(file => ({
      file: path.basename(file),
      path: file,
      mtime: fs.statSync(file).mtime
    }));
    
    // Find oldest and newest files
    const oldest = fileStats.reduce((oldest, current) => 
      current.mtime < oldest.mtime ? current : oldest
    );
    const newest = fileStats.reduce((newest, current) => 
      current.mtime > newest.mtime ? current : newest
    );
    
    const timeDiff = newest.mtime - oldest.mtime;
    const daysDiff = timeDiff / (1000 * 60 * 60 * 24);
    
    if (daysDiff > 1) { // Files more than 1 day apart
      inconsistencies.push({
        severity: 'MEDIUM',
        type: 'DOCUMENTATION_DRIFT',
        description: `Documentation files have inconsistent timestamps (${daysDiff.toFixed(1)} days apart)`,
        impact: 'Documentation may not reflect current system state',
        oldestFile: oldest.file,
        newestFile: newest.file,
        recommendations: [
          'Synchronize all documentation updates',
          'Implement automated documentation updates',
          'Regular documentation review cycle'
        ]
      });
    }
    
    const status = inconsistencies.length === 0 ? 'CONSISTENT' : 'MINOR_ISSUES';
    
    return {
      status,
      summary: `Documentation synchronization validated, ${inconsistencies.length} issues found`,
      inconsistencies,
      metrics: {
        artifactFiles: artifactFiles.length,
        oldestFile: oldest.file,
        newestFile: newest.file,
        daysBetween: daysDiff.toFixed(1)
      }
    };
  }

  generateValidationReport(validationResults) {
    console.log('\n📊 CONSISTENCY VALIDATION REPORT');
    console.log('=================================');
    
    const summary = {
      totalInconsistencies: this.inconsistencies.length,
      criticalIssues: this.inconsistencies.filter(i => i.severity === 'CRITICAL').length,
      highIssues: this.inconsistencies.filter(i => i.severity === 'HIGH').length,
      mediumIssues: this.inconsistencies.filter(i => i.severity === 'MEDIUM').length,
      categories: Object.keys(validationResults).length
    };
    
    console.log(`📈 Categories Validated: ${summary.categories}`);
    console.log(`📊 Total Inconsistencies: ${summary.totalInconsistencies}`);
    console.log(`🚨 Critical Issues: ${summary.criticalIssues}`);
    console.log(`⚠️  High Priority Issues: ${summary.highIssues}`);
    console.log(`📋 Medium Priority Issues: ${summary.mediumIssues}`);
    
    if (summary.criticalIssues > 0) {
      console.log('\n🚨 CRITICAL INCONSISTENCIES DETECTED:');
      this.inconsistencies
        .filter(i => i.severity === 'CRITICAL')
        .slice(0, 5) // Show first 5 critical issues
        .forEach((issue, index) => {
          console.log(`\n${index + 1}. ${issue.type} (${issue.category})`);
          console.log(`   Description: ${issue.description}`);
          console.log(`   Impact: ${issue.impact}`);
          if (issue.recommendations) {
            console.log(`   Recommendations:`);
            issue.recommendations.forEach(rec => console.log(`   - ${rec}`));
          }
        });
        
      if (summary.criticalIssues > 5) {
        console.log(`\n... and ${summary.criticalIssues - 5} more critical issues`);
      }
    }
    
    // Save detailed report
    this.saveValidationReport(validationResults, summary);
  }

  saveValidationReport(validationResults, summary) {
    const reportPath = path.join(this.artifactsDir, 'consistency-validation-report.yml');
    
    const report = {
      metadata: {
        generated_at: new Date().toISOString(),
        validator_version: '1.0.0',
        validation_scope: Object.keys(this.validationRules)
      },
      summary,
      validation_results: validationResults,
      inconsistencies: this.inconsistencies,
      recommendations: this.generateRecommendations()
    };
    
    fs.writeFileSync(reportPath, yaml.dump(report));
    console.log(`\n📄 Detailed report saved: ${reportPath}`);
  }

  generateRecommendations() {
    const recommendations = [];
    
    // Priority recommendations based on inconsistencies
    const criticalIssues = this.inconsistencies.filter(i => i.severity === 'CRITICAL');
    const highIssues = this.inconsistencies.filter(i => i.severity === 'HIGH');
    
    if (criticalIssues.length > 0) {
      recommendations.push({
        priority: 'IMMEDIATE',
        action: 'Address critical inconsistencies',
        description: `${criticalIssues.length} critical inconsistencies blocking system functionality`,
        timeline: 'THIS_WEEK'
      });
    }
    
    if (highIssues.length > 0) {
      recommendations.push({
        priority: 'HIGH',
        action: 'Resolve high-priority inconsistencies',
        description: `${highIssues.length} high-priority issues affecting system quality`,
        timeline: 'NEXT_2_WEEKS'
      });
    }
    
    // Category-specific recommendations
    const categoryIssues = this.groupInconsistenciesByCategory();
    
    Object.entries(categoryIssues).forEach(([category, issues]) => {
      if (issues.length > 0) {
        recommendations.push({
          priority: 'MEDIUM',
          action: `Improve ${category}`,
          description: `${issues.length} inconsistencies in ${category} category`,
          timeline: 'ONGOING'
        });
      }
    });
    
    return recommendations;
  }

  groupInconsistenciesByCategory() {
    const grouped = {};
    
    this.inconsistencies.forEach(inconsistency => {
      const category = inconsistency.category || 'unknown';
      if (!grouped[category]) {
        grouped[category] = [];
      }
      grouped[category].push(inconsistency);
    });
    
    return grouped;
  }

  async updateErrorReportsIfNeeded() {
    // If we found new critical issues, update the error reports
    const newCriticalIssues = this.inconsistencies.filter(i => i.severity === 'CRITICAL');
    
    if (newCriticalIssues.length > 0) {
      console.log(`\n📝 Updating error reports with ${newCriticalIssues.length} new critical issues...`);
      
      const errorReportsPath = path.join(this.artifactsDir, 'error-reports.md');
      if (fs.existsSync(errorReportsPath)) {
        const currentContent = fs.readFileSync(errorReportsPath, 'utf8');
        
        // Add new issues section
        const newIssuesSection = this.generateNewIssuesSection(newCriticalIssues);
        const updatedContent = currentContent + '\n\n' + newIssuesSection;
        
        fs.writeFileSync(errorReportsPath, updatedContent);
        console.log('✅ Error reports updated with new critical issues');
      }
    }
  }

  generateNewIssuesSection(criticalIssues) {
    const timestamp = new Date().toISOString();
    
    let section = `## 🚨 NEW CRITICAL ISSUES DETECTED - ${timestamp}\n\n`;
    section += `**Detected by**: Consistency Validation Engine\n`;
    section += `**Issue Count**: ${criticalIssues.length} new critical inconsistencies\n\n`;
    
    criticalIssues.forEach((issue, index) => {
      section += `### ${index + 1}. **${issue.type}** - SEVERITY: CRITICAL\n`;
      section += `**Category**: ${issue.category}\n`;
      section += `**Description**: ${issue.description}\n`;
      section += `**Impact**: ${issue.impact}\n\n`;
      
      if (issue.recommendations) {
        section += `**Recommended Actions**:\n`;
        issue.recommendations.forEach(rec => {
          section += `- ${rec}\n`;
        });
        section += '\n';
      }
    });
    
    return section;
  }
}

// Error handling
process.on('uncaughtException', (error) => {
  console.error('🚨 VALIDATION SYSTEM ERROR:', error);
  process.exit(1);
});

// CLI interface
if (require.main === module) {
  const validator = new ConsistencyValidator();
  
  const args = process.argv.slice(2);
  
  if (args.includes('--watch')) {
    console.log('👁️  Starting continuous consistency monitoring...');
    
    // Run initial validation
    validator.runFullValidation().then(result => {
      console.log(`\n✅ Initial validation completed: ${result.totalInconsistencies} issues found`);
      
      // Set up file watching for continuous validation
      const chokidar = require('chokidar');
      
      const watcher = chokidar.watch([
        path.join(validator.artifactsDir, '**/*'),
        path.join(validator.backendDir, 'src/**/*')
      ], {
        ignored: /node_modules/,
        persistent: true
      });
      
      let validationTimeout;
      
      watcher.on('change', (filePath) => {
        console.log(`📝 File changed: ${path.basename(filePath)}`);
        
        // Debounce validation to avoid excessive runs
        clearTimeout(validationTimeout);
        validationTimeout = setTimeout(() => {
          console.log('🔍 Running consistency validation...');
          validator.runFullValidation().then(result => {
            if (result.criticalIssues > 0) {
              console.log(`🚨 ${result.criticalIssues} critical inconsistencies detected!`);
            } else {
              console.log('✅ Consistency validation passed');
            }
          });
        }, 2000);
      });
      
      console.log('👁️  Continuous monitoring active...');
    });
    
  } else {
    // Run single validation
    validator.runFullValidation().then(result => {
      const exitCode = result.criticalIssues > 0 ? 1 : 0;
      process.exit(exitCode);
    });
  }
}

module.exports = ConsistencyValidator;