# ============================================================================
# LOGSTASH SECURITY EVENTS PROCESSING PIPELINE
# ============================================================================
#
# Complete security event processing pipeline for SIEM infrastructure
# Real-time normalization, enrichment, and correlation of security events
#
# Created by: DEVOPS-AGENT - TIER 1 Advanced Threat Protection
# Date: 2025-08-14
# Version: 1.0.0
# ============================================================================

# ========================================
# INPUT SECTION - Security Event Sources
# ========================================

input {
  # Beats Input for Filebeat Security Logs
  beats {
    port => 5044
    type => "security-beats"
    host => "0.0.0.0"
    ssl => false
  }

  # TCP Input for Application Security Events
  tcp {
    port => 5000
    type => "application-security"
    codec => json_lines
  }

  # Syslog Input for System Security Events
  syslog {
    port => 5140
    type => "system-security"
    facility_labels => ["kernel", "mail", "daemon", "auth", "syslog", "lpr", "news", "uucp", "cron", "authpriv", "ftp", "local0", "local1", "local2", "local3", "local4", "local5", "local6", "local7"]
    severity_labels => ["emergency", "alert", "critical", "error", "warning", "notice", "informational", "debug"]
  }

  # HTTP Input for Webhook Security Events
  http {
    port => 8088
    type => "webhook-security"
    codec => json
  }

  # UDP Input for Syslog Security Events
  udp {
    port => 5141
    type => "syslog-security"
    codec => plain
  }

  # File Input for Security Log Files
  file {
    path => [
      "/var/log/auth.log",
      "/var/log/secure",
      "/var/log/audit/audit.log",
      "/var/log/nginx/access.log",
      "/var/log/nginx/error.log",
      "/var/log/docker/*/*-json.log"
    ]
    start_position => "beginning"
    type => "security-file"
    codec => multiline {
      pattern => "^%{TIMESTAMP_ISO8601}"
      negate => true
      what => "previous"
    }
  }
}

# ========================================
# FILTER SECTION - Security Event Processing
# ========================================

filter {
  # Add Common Fields
  mutate {
    add_field => {
      "[@metadata][pipeline]" => "security-events"
      "[@metadata][version]" => "1.0.0"
      "security_grade_impact" => "processing"
    }
    add_tag => ["siem", "security", "devops-agent-processed"]
  }

  # Parse Different Log Types
  if [type] == "application-security" {
    # Parse Application Security Events
    if [message] =~ /authentication/ {
      grok {
        match => { 
          "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{LOGLEVEL:level}\] %{WORD:event_type}: User %{WORD:username} %{WORD:action} from IP %{IP:source_ip}"
        }
        add_tag => ["authentication"]
      }
    }

    if [message] =~ /authorization/ {
      grok {
        match => { 
          "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{LOGLEVEL:level}\] RBAC: User %{WORD:username} %{WORD:action} access to %{WORD:resource}"
        }
        add_tag => ["authorization"]
      }
    }

    if [message] =~ /encryption/ {
      grok {
        match => { 
          "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{LOGLEVEL:level}\] ENCRYPTION: %{WORD:crypto_operation} %{WORD:status} for %{WORD:data_type}"
        }
        add_tag => ["encryption"]
      }
    }

    if [message] =~ /sql_injection/ {
      grok {
        match => { 
          "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{LOGLEVEL:level}\] SQL_INJECTION: Attempt from IP %{IP:source_ip} blocked"
        }
        add_tag => ["sql_injection", "critical"]
      }
      mutate {
        add_field => { "security_severity" => "critical" }
        add_field => { "attack_type" => "sql_injection" }
      }
    }
  }

  if [type] == "system-security" {
    # Parse System Security Events
    grok {
      match => { 
        "message" => "%{SYSLOGTIMESTAMP:timestamp} %{IPORHOST:host} %{WORD:program}(?:\[%{POSINT:pid}\])?: %{GREEDYDATA:system_message}"
      }
    }

    if [program] == "sshd" {
      if [system_message] =~ /Failed password/ {
        mutate {
          add_tag => ["ssh_failed_login", "authentication_failure"]
          add_field => { "security_severity" => "medium" }
        }
      }
      if [system_message] =~ /Accepted password/ {
        mutate {
          add_tag => ["ssh_successful_login"]
          add_field => { "security_severity" => "info" }
        }
      }
    }

    if [program] == "sudo" {
      mutate {
        add_tag => ["privilege_escalation"]
        add_field => { "security_severity" => "medium" }
      }
    }
  }

  if [type] == "security-file" {
    # Parse Nginx Access Logs for Security Analysis
    if [path] =~ /nginx.*access/ {
      grok {
        match => { 
          "message" => "%{NGINXACCESS}"
        }
        patterns_dir => ["/usr/share/logstash/patterns"]
      }

      # Detect potential attacks in HTTP requests
      if [request] {
        if [request] =~ /(\.\./|\.\.\\|\/etc\/passwd|\/proc\/|cmd=|exec\(|system\(|<script|javascript:|onerror=)/ {
          mutate {
            add_tag => ["web_attack", "suspicious_request"]
            add_field => { "security_severity" => "high" }
            add_field => { "attack_type" => "web_attack" }
          }
        }

        # Check for SQL injection patterns
        if [request] =~ /(union.*select|insert.*into|delete.*from|drop.*table|'.*or.*'|admin'--|' or 1=1)/ {
          mutate {
            add_tag => ["sql_injection", "web_attack"]
            add_field => { "security_severity" => "critical" }
            add_field => { "attack_type" => "sql_injection" }
          }
        }

        # Check for XSS patterns
        if [request] =~ /(<script|javascript:|onerror=|onload=|alert\(|confirm\(|prompt\()/ {
          mutate {
            add_tag => ["xss_attack", "web_attack"]
            add_field => { "security_severity" => "high" }
            add_field => { "attack_type" => "xss" }
          }
        }
      }

      # Analyze response codes for security issues
      if [response] {
        if [response] in ["401", "403"] {
          mutate {
            add_tag => ["access_denied"]
            add_field => { "security_severity" => "medium" }
          }
        }
        if [response] in ["500", "502", "503"] {
          mutate {
            add_tag => ["service_error", "potential_attack"]
            add_field => { "security_severity" => "medium" }
          }
        }
      }
    }

    # Parse Docker Container Logs
    if [path] =~ /docker/ {
      json {
        source => "message"
        target => "docker"
      }
      
      if [docker][log] {
        mutate {
          replace => { "message" => "%{[docker][log]}" }
        }
      }
    }
  }

  # Parse JSON Security Events
  if [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
      target => "parsed_json"
    }
  }

  # GeoIP Enrichment for Source IPs
  if [source_ip] {
    geoip {
      source => "source_ip"
      target => "geoip"
      add_tag => ["geoip"]
    }
  }

  if [clientip] {
    geoip {
      source => "clientip"
      target => "geoip"
      add_tag => ["geoip"]
    }
  }

  # Date Processing
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss", "MMM dd HH:mm:ss", "MMM  d HH:mm:ss" ]
      target => "@timestamp"
    }
  }

  # User Agent Analysis
  if [agent] {
    useragent {
      source => "agent"
      target => "user_agent"
    }
  }

  # Security Event Correlation
  if "authentication" in [tags] {
    mutate {
      add_field => { "event_category" => "authentication" }
    }
  }

  if "authorization" in [tags] {
    mutate {
      add_field => { "event_category" => "authorization" }
    }
  }

  if "web_attack" in [tags] {
    mutate {
      add_field => { "event_category" => "network_attack" }
    }
  }

  if "sql_injection" in [tags] {
    mutate {
      add_field => { "event_category" => "data_attack" }
      add_field => { "security_priority" => "immediate" }
    }
  }

  # Calculate Security Score
  ruby {
    code => "
      severity = event.get('security_severity')
      score = case severity
        when 'critical' then 10
        when 'high' then 8
        when 'medium' then 5
        when 'low' then 2
        when 'info' then 1
        else 0
      end
      event.set('security_score', score)
    "
  }

  # Remove unwanted fields
  mutate {
    remove_field => ["beat", "prospector", "input", "offset", "ecs", "@version"]
  }
}

# ========================================
# OUTPUT SECTION - Security Event Storage
# ========================================

output {
  # Output to Elasticsearch for SIEM Storage
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    user => "elastic"
    password => "${ELASTICSEARCH_PASSWORD}"
    
    # Dynamic index routing based on event type
    index => "siem-events-%{+YYYY.MM.dd}"
    
    # Document type routing
    template_name => "siem-security-events"
    template_pattern => "siem-*"
    template => {
      "index_patterns" => ["siem-*"]
      "settings" => {
        "number_of_shards" => 1
        "number_of_replicas" => 0
        "refresh_interval" => "5s"
        "index.mapping.total_fields.limit" => 2000
      }
      "mappings" => {
        "properties" => {
          "@timestamp" => { "type" => "date" }
          "source_ip" => { "type" => "ip" }
          "clientip" => { "type" => "ip" }
          "security_score" => { "type" => "integer" }
          "geoip" => {
            "properties" => {
              "location" => { "type" => "geo_point" }
            }
          }
        }
      }
    }
  }

  # Output Critical Events to Security Alerts Index
  if [security_severity] == "critical" {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      user => "elastic"
      password => "${ELASTICSEARCH_PASSWORD}"
      index => "security-alerts-%{+YYYY.MM.dd}"
    }
  }

  # Debug Output (Remove in Production)
  if [type] == "debug" {
    stdout {
      codec => rubydebug
    }
  }
}