# ============================================================================
# WASTE MANAGEMENT SYSTEM - PRODUCTION DOCKER COMPOSE WITH SECRETS
# ============================================================================
#
# Production-ready Docker environment with Docker Secrets integration
# for secure credential management. Replaces insecure environment variable
# defaults with Docker Secrets for enterprise-grade security.
#
# Created by: Security & Compliance Specialist
# Date: 2025-08-15
# Version: 1.0.0 - Production Secrets Management
# ============================================================================

version: '3.8'

# Docker Secrets definition for production deployment
secrets:
  # Database Credentials
  db_password:
    file: ./secrets/db_password.txt
  redis_password:
    file: ./secrets/redis_password.txt
  
  # JWT Authentication Keys (RS256 Private/Public Key Pairs)
  jwt_private_key:
    file: ./secrets/jwt_private_key.pem
  jwt_public_key:
    file: ./secrets/jwt_public_key.pem
  jwt_refresh_private_key:
    file: ./secrets/jwt_refresh_private_key.pem
  jwt_refresh_public_key:
    file: ./secrets/jwt_refresh_public_key.pem
  
  # Encryption and Session Keys
  encryption_key:
    file: ./secrets/encryption_key.txt
  session_secret:
    file: ./secrets/session_secret.txt
  
  # External Service API Keys
  stripe_secret_key:
    file: ./secrets/stripe_secret_key.txt
  stripe_webhook_secret:
    file: ./secrets/stripe_webhook_secret.txt
  twilio_auth_token:
    file: ./secrets/twilio_auth_token.txt
  sendgrid_api_key:
    file: ./secrets/sendgrid_api_key.txt
  samsara_api_token:
    file: ./secrets/samsara_api_token.txt
  samsara_webhook_secret:
    file: ./secrets/samsara_webhook_secret.txt
  airtable_api_key:
    file: ./secrets/airtable_api_key.txt
  mapbox_access_token:
    file: ./secrets/mapbox_access_token.txt
  
  # AWS Credentials
  aws_access_key_id:
    file: ./secrets/aws_access_key_id.txt
  aws_secret_access_key:
    file: ./secrets/aws_secret_access_key.txt
  
  # Administrative Interface Passwords
  redis_commander_password:
    file: ./secrets/redis_commander_password.txt
  pgadmin_password:
    file: ./secrets/pgadmin_password.txt
  grafana_password:
    file: ./secrets/grafana_password.txt

services:
  # PostgreSQL 16 with PostGIS for spatial data
  postgres:
    image: postgis/postgis:16-3.4
    container_name: waste-mgmt-postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: waste_management
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD_FILE: /run/secrets/db_password
      POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
    ports:
      - "${DB_PORT:-5432}:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./docker/postgres/init:/docker-entrypoint-initdb.d
      - ./docker/postgres/config/postgresql.conf:/etc/postgresql/postgresql.conf
    networks:
      - waste-mgmt-network
    secrets:
      - db_password
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d waste_management"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    command: ["postgres", "-c", "config_file=/etc/postgresql/postgresql.conf"]

  # Redis for caching, sessions, and background job queues
  redis:
    image: redis:7-alpine
    container_name: waste-mgmt-redis
    restart: unless-stopped
    command: |
      sh -c '
        REDIS_PASSWORD=$$(cat /run/secrets/redis_password)
        redis-server --appendonly yes --requirepass "$$REDIS_PASSWORD"
      '
    ports:
      - "${REDIS_PORT:-6379}:6379"
    volumes:
      - redis_data:/data
      - ./docker/redis/redis.conf:/usr/local/etc/redis/redis.conf
    networks:
      - waste-mgmt-network
    secrets:
      - redis_password
    healthcheck:
      test: |
        sh -c '
          REDIS_PASSWORD=$$(cat /run/secrets/redis_password)
          redis-cli -a "$$REDIS_PASSWORD" ping
        '
      interval: 10s
      timeout: 3s
      retries: 5
      start_period: 10s

  # Backend API Application
  backend:
    build:
      context: .
      dockerfile: ./docker/Dockerfile
      target: production
    container_name: waste-mgmt-backend
    restart: unless-stopped
    environment:
      NODE_ENV: production
      PORT: ${PORT:-3001}
      
      # Database Configuration (password from secret)
      DB_HOST: postgres
      DB_PORT: 5432
      DB_NAME: waste_management
      DB_USERNAME: postgres
      DB_SSL: true
      
      # Redis Configuration (password from secret)
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_DB: 0
      REDIS_KEY_PREFIX: "waste_mgmt:"
      REDIS_TTL_DEFAULT: 3600
      
      # JWT Configuration (keys from secrets)
      JWT_EXPIRES_IN: 15m
      JWT_REFRESH_EXPIRES_IN: 7d
      JWT_ALGORITHM: RS256
      JWT_ISSUER: waste-management-api
      JWT_AUDIENCE: waste-management-users
      
      # Security Configuration
      HASH_ROUNDS: 12
      
      # Production Settings
      DEBUG_SQL: false
      ENABLE_SWAGGER_UI: false
      ENABLE_API_DOCS: false
      LOG_LEVEL: info
      
      # Health Check Configuration
      HEALTH_CHECK_ENABLED: true
      HEALTH_CHECK_DATABASE: true
      HEALTH_CHECK_REDIS: true
      HEALTH_CHECK_EXTERNAL_APIS: true
      
      # Background Jobs
      QUEUE_REDIS_HOST: redis
      QUEUE_REDIS_PORT: 6379
      QUEUE_REDIS_DB: 1
      ENABLE_QUEUE_DASHBOARD: false
      
      # Security Headers
      FORCE_HTTPS: true
      TRUST_PROXY: true
      SECURE_COOKIES: true
      
    ports:
      - "${PORT:-3001}:${PORT:-3001}"
    volumes:
      - backend_uploads:/app/uploads
      - backend_logs:/app/logs
    networks:
      - waste-mgmt-network
    secrets:
      - db_password
      - redis_password
      - jwt_private_key
      - jwt_public_key
      - jwt_refresh_private_key
      - jwt_refresh_public_key
      - encryption_key
      - session_secret
      - stripe_secret_key
      - stripe_webhook_secret
      - twilio_auth_token
      - sendgrid_api_key
      - samsara_api_token
      - samsara_webhook_secret
      - airtable_api_key
      - mapbox_access_token
      - aws_access_key_id
      - aws_secret_access_key
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:${PORT:-3001}/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  # Frontend Application (Next.js)
  frontend:
    build:
      context: ./frontend
      dockerfile: ../docker/Dockerfile.frontend
      target: production
    container_name: waste-mgmt-frontend
    restart: unless-stopped
    environment:
      NODE_ENV: production
      NEXT_PUBLIC_API_URL: https://${DOMAIN:-localhost}:${PORT:-3001}
      NEXT_PUBLIC_WEBSOCKET_URL: wss://${DOMAIN:-localhost}:${WEBSOCKET_PORT:-3002}
    ports:
      - "${FRONTEND_PORT:-3000}:3000"
    networks:
      - waste-mgmt-network
    depends_on:
      backend:
        condition: service_healthy

  # Redis Commander (Redis management UI) - Secured with Docker Secrets
  redis-commander:
    image: rediscommander/redis-commander:latest
    container_name: waste-mgmt-redis-commander
    restart: unless-stopped
    environment:
      HTTP_USER: admin
    command: |
      sh -c '
        REDIS_PASSWORD=$$(cat /run/secrets/redis_password)
        HTTP_PASSWORD=$$(cat /run/secrets/redis_commander_password)
        export REDIS_HOSTS="local:redis:6379:1:$$REDIS_PASSWORD"
        export HTTP_PASSWORD="$$HTTP_PASSWORD"
        redis-commander
      '
    ports:
      - "${REDIS_COMMANDER_PORT:-8081}:8081"
    networks:
      - waste-mgmt-network
    secrets:
      - redis_password
      - redis_commander_password
    depends_on:
      redis:
        condition: service_healthy
    profiles:
      - tools

  # pgAdmin (PostgreSQL management UI) - Secured with Docker Secrets
  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: waste-mgmt-pgadmin
    restart: unless-stopped
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_EMAIL:-admin@waste-mgmt.com}
      PGADMIN_DEFAULT_PASSWORD_FILE: /run/secrets/pgadmin_password
      PGADMIN_LISTEN_PORT: 80
    ports:
      - "${PGADMIN_PORT:-8080}:80"
    volumes:
      - pgadmin_data:/var/lib/pgadmin
      - ./docker/pgadmin/servers.json:/pgadmin4/servers.json
    networks:
      - waste-mgmt-network
    secrets:
      - pgadmin_password
    depends_on:
      postgres:
        condition: service_healthy
    profiles:
      - tools

  # Nginx (Reverse Proxy and Load Balancer)
  nginx:
    image: nginx:alpine
    container_name: waste-mgmt-nginx
    restart: unless-stopped
    ports:
      - "${NGINX_HTTP_PORT:-80}:80"
      - "${NGINX_HTTPS_PORT:-443}:443"
    volumes:
      - ./docker/nginx/nginx.prod.conf:/etc/nginx/nginx.conf
      - ./docker/nginx/sites-enabled:/etc/nginx/sites-enabled
      - ./docker/nginx/ssl:/etc/nginx/ssl
      - nginx_logs:/var/log/nginx
    networks:
      - waste-mgmt-network
    depends_on:
      - backend
      - frontend
    profiles:
      - production

  # Prometheus (Metrics Collection)
  prometheus:
    image: prom/prometheus:latest
    container_name: waste-mgmt-prometheus
    restart: unless-stopped
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=30d'
      - '--web.enable-lifecycle'
    ports:
      - "${PROMETHEUS_PORT:-9090}:9090"
    volumes:
      - ./docker/prometheus/prometheus.prod.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    networks:
      - waste-mgmt-network
    profiles:
      - monitoring

  # Grafana (Metrics Visualization) - Secured with Docker Secrets
  grafana:
    image: grafana/grafana:latest
    container_name: waste-mgmt-grafana
    restart: unless-stopped
    environment:
      GF_SECURITY_ADMIN_USER: ${GRAFANA_USER:-admin}
      GF_SECURITY_ADMIN_PASSWORD__FILE: /run/secrets/grafana_password
      GF_INSTALL_PLUGINS: grafana-clock-panel,grafana-simple-json-datasource
    ports:
      - "${GRAFANA_PORT:-3004}:3000"
    volumes:
      - grafana_data:/var/lib/grafana
      - ./docker/grafana/provisioning:/etc/grafana/provisioning
      - ./docker/grafana/dashboards:/var/lib/grafana/dashboards
    networks:
      - waste-mgmt-network
    secrets:
      - grafana_password
    depends_on:
      - prometheus
    profiles:
      - monitoring

# Persistent volumes for data persistence
volumes:
  postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH:-./docker/data}/postgres
  redis_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH:-./docker/data}/redis
  backend_uploads:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH:-./docker/data}/uploads
  backend_logs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${DATA_PATH:-./docker/data}/logs
  pgadmin_data:
    driver: local
  grafana_data:
    driver: local
  prometheus_data:
    driver: local
  nginx_logs:
    driver: local

# Network configuration
networks:
  waste-mgmt-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16